<!DOCTYPE html>

<html>
<head>
<title>Bif File Parser</title>

<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<style type="text/css">
    body { 
        font: 14px Arial; 
    }
</style>

<script type="text/javascript">

    var BifParser = {

        getMagicString: function(b) {
            var magicIdentifier = [b[0].charCodeAt(0) & 0xff, b[1].charCodeAt(0) & 0xff, 
                                   b[2].charCodeAt(0) & 0xff, b[3].charCodeAt(0) & 0xff, 
                                   b[4].charCodeAt(0) & 0xff, b[5].charCodeAt(0) & 0xff, 
                                   b[6].charCodeAt(0) & 0xff, b[7].charCodeAt(0) & 0xff, 
                                   b[8].charCodeAt(0) & 0xff];
            //console.log("---- var magicIdentifier = ", magicIdentifier);
            document.getElementById("magic").innerHTML = "magicIdentifier = " + magicIdentifier;

            return magicIdentifier;
        },
		
        validateBifMagicString: function(magicIdentifier) {
            // spot check
            if ( magicIdentifier[0] != 137 || magicIdentifier[6] != 26 ) {
                return false;
            }

            return true;
        },
		
        getHeaderValue: function(b, title) {
            var rawBytes = [b[0].charCodeAt(0) & 0xff, b[1].charCodeAt(0) & 0xff,
                            b[2].charCodeAt(0) & 0xff, b[3].charCodeAt(0) & 0xff];
            var value = ByteUtilites.shift32Bits(rawBytes,0)

            // console.log("---- var " + title + " = ", value);
            document.getElementById(title).innerHTML = title + " = " + value;

            return value;
        },

        getHeaderInfo: function(b) {
            if( !b || b.length < 64 ) {
                return 0;
            }
			
            magicString = this.getMagicString(b.slice(0,9));

            if ( !this.validateBifMagicString(magicString) ) {
                return 0;
            }

            var version = this.getHeaderValue(b.slice(8,12), "version");
            var imageCount = this.getHeaderValue(b.slice(12,16), "imageCount");
            var timestampMultipler = this.getHeaderValue(b.slice(16,20), "timestampMultipler");

            return imageCount;
        },

        getVisibleFrames: function(b, index) {
            var count = 0;
            var bifIndexSearchAtPosition = 64 + (8 * index);
            var frameOffset = 0;
            var previousFrameOffset = 0;
            var offsetMessageInfo = "";
            var forwardPNGEncodeString = "data:image/png;base64,"
            var forwardJPEGEncodeString = "data:image/jpeg;base64,"

            while( count <= WebBrowserInterface.imageFrameCount ) {

                var indexBytes = [b[bifIndexSearchAtPosition].charCodeAt(0) & 0xff,b[bifIndexSearchAtPosition+1].charCodeAt(0) & 0xff,
                                  b[bifIndexSearchAtPosition+2].charCodeAt(0) & 0xff,b[bifIndexSearchAtPosition+3].charCodeAt(0) & 0xff];
                index = ByteUtilites.shift32Bits(indexBytes,0);
                // console.log("---- var index = ", index);

                bifIndexSearchAtPosition += 4;

                var frameOffsetBytes = [b[bifIndexSearchAtPosition].charCodeAt(0) & 0xff,b[bifIndexSearchAtPosition+1].charCodeAt(0) & 0xff,
                                        b[bifIndexSearchAtPosition+2].charCodeAt(0) & 0xff,b[bifIndexSearchAtPosition+3].charCodeAt(0) & 0xff];
                frameOffset = ByteUtilites.shift32Bits(frameOffsetBytes,0);
                // console.log("---- var frameOffset = ", frameOffset);

                offsetMessageInfo += " index: " + index + " fos bytes: " + frameOffset + "<br />";

                if ( count > 0 ) {

                    var j = 0;
                    var buffer = "";

                    for (var i = previousFrameOffset; i <= frameOffset-1; i++ ) {
                        buffer += b[i];
                        j++;
                    }

                    // console.log("---- var buffer[] = ", buffer);
                    // mozilla and webkit specific. Use Base64.encode function if not working.
                    // var base64Buffer = btoa(buffer);

                    var base64Buffer = ByteUtilites.Base64.encode(buffer);
                    // console.log("---- var base64Buffer = ", base64Buffer);

                    // dump to the window
                    if ( count <= WebBrowserInterface.imageFrameCount ) {
                        finalBase64Encode = forwardJPEGEncodeString + base64Buffer;

                        if ( buffer.slice(1,4) == "PNG" ) {
                            finalBase64Encode = forwardPNGEncodeString + base64Buffer;
                        }

                        // console.log("finalBase64Encode = ", finalBase64Encode);

                       document.getElementById("image"+count).setAttribute("src",finalBase64Encode);
                    }
                }

                previousFrameOffset = frameOffset;
                // console.log("---- var previousFrameOffset = ", previousFrameOffset);

                bifIndexSearchAtPosition += 4;

                count += 1;
            }

            document.getElementById("offsetMessageInfo").innerHTML = "offsetMessageInfo = " + offsetMessageInfo;
        }
    }

    var ByteUtilites = {
        shift32Bits: function(arr, offs) {
		
            // console.log("--- shift32Bits in: ", arr);

            // little endianness, shift 4 bytes in reverse
            var out = (arr[offs+3] << 24) +
                      (arr[offs+2] << 16) +
                      (arr[offs+1] << 8) +
                       arr[offs+0]

            // console.log("--- shift32Bits out: ", out);

            return out;
        },

        Base64 : {

            _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

            encode : function (input) {
                var output = "";
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0;

                while (i < input.length) {

                    chr1 = input.charCodeAt(i++) & 0xff;
                    chr2 = input.charCodeAt(i++) & 0xff;
                    chr3 = input.charCodeAt(i++) & 0xff;

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output +
                    this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
                    this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
                }

                return output;
            }
			
        }
		
    }

    var WebBrowserInterface = {
        imageFrameCount: 4,
        bifImageCount: 0,
        bifFrameIndex: 0,
        bifBinary: null,

        reset: function() {
            this.bifImageCount = 0;
            this.bifFrameIndex = 0;
            this.bifBinary = null;
        },

        uploadBifBlob: function(files) {
            if (!files) {
                alert('Files not found!');
                return;
            }

            if (!files.length) {
                alert('Please select a bif file!');
                return;
            }

            // reset the indices
            this.reset();

            var file = files[0];
            var start = 0;
            var stop = file.size - 1;

            var reader = new FileReader();

            reader.onloadend = function(evt) {
                if (evt.target.readyState == FileReader.DONE) {
                    document.getElementById('byte_range').textContent = file.size + ' byte file'
					
                    var result = evt.target.result;
                    WebBrowserInterface.bifBinary = result;
					
                    // console.log("WebBrowserInterface.bifBinary = " + WebBrowserInterface.bifBinary);
					
                    WebBrowserInterface.bifImageCount = BifParser.getHeaderInfo(result);
					
                    if( WebBrowserInterface.bifImageCount < 1 ) {
                        alert('Invalid bif file.');
                        return;
                    }
					
                    BifParser.getVisibleFrames(result, 0);
                }
            };

            reader.onerror = function(evt) {
                // console.log("error reading: code " + evt.target.error.code);

                switch(evt.target.error.code) {
                case evt.target.error.NOT_FOUND_ERR:
                    alert('evt.target.error.NOT_FOUND_ERR');
                    break;
                case evt.target.error.NOT_READABLE_ERR:
                    alert('evt.target.error.NOT_READABLE_ERRR');
                    break;
                case evt.target.error.ENCODING_ERR:
                    alert('evt.target.error.ENCODING_ERR');
                    break;
                case evt.target.error.SECURITY_ERR:
                    alert('evt.target.error.SECURITY_ERR');
                    break;
                case evt.target.error.ABORT_ERR:
                    break;
                default:
                    alert('An error occurred reading this file.');
                }
            }

            var blob = file;

            if (file.webkitSlice) {
                var blob = file.webkitSlice(start, stop + 1);
            } else if (file.mozSlice) {
                var blob = file.mozSlice(start, stop + 1);
            }
	
            reader.readAsBinaryString(blob);
        },

        skipToFrame: function(index) {
            // console.log("this.bifFrameIndex = " + this.bifFrameIndex + " this.bifImageCount = " + this.bifImageCount);
            // console.log("this.bifBinary (memory) = " + this.bifBinary.length);

            // backward protection
            if ( this.bifFrameIndex + index < 0 ) {
                return;
            }

            // forward protection
            if ( index != -1 && (this.bifFrameIndex >= (this.bifImageCount - this.imageFrameCount)) ) {
                return;
            }

            this.bifFrameIndex += index;
            BifParser.getVisibleFrames(this.bifBinary, this.bifFrameIndex);
        }

    }

</script>
</head>
    <body>

    <fieldset>

        <legend>Upload Bif file</legend>

        <input type="file" id="files" name="file" /> Read bytes: 
        <span class="readBytesButtons">
            <button id="testing">Read and Parse</button>
        </span>
        <div id="byte_range"></div>

        <hr/>

        <div id="magic">magicIdentifier = </div>
        <div id="version">version = </div>
        <div id="imageCount">imageCount = </div>
        <div id="timestampMultipler">timestampMultipler = </div>
        <div id="offsetMessageInfo">offsetMessageInfo = </div><br />

        <a href="javascript:WebBrowserInterface.skipToFrame(-1);">Backward</a> 
        <img id="image1" /> 
        <img id="image2" /> 
        <img id="image3" /> 
        <img id="image4" /> 
        <a href="javascript:WebBrowserInterface.skipToFrame(1);">Forward</a>

    </fieldset>

    <script type="text/javascript">

        document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
            if (evt.target.tagName.toLowerCase() == 'button') {
                var files = document.getElementById('files').files;
                WebBrowserInterface.uploadBifBlob(files);
           }
        }, false);

    </script>

    </body>
</html>